// Name: Micaela Sousa (0722724), Rachel Lee (0696297), Boaz Chan (0686531)
// Assignment 1

// Program description:
// TO COMPLETE!!!

// Data dictionary: 
// TO COMPLETE!!!

// Task 1: Server Graph

public class ServerGraph
{
// 3 marks
private class WebServer
{
public string Name;
public List<WebPage> P;
...
}
private WebServer[] V {set; get; } 
private bool[,] E {set; get; } 
private int NumServers {set; get; } 
private int MaxNumServers {set; get; } 
...

// 2 marks
// Create an empty server graph
public ServerGraph(int maxNumServers) 
 {
	NumServers= 0;
        MaxNumServers = maxNumServers;
        V = new WebServer[maxNumServers];
        E = new bool[maxNumServers, maxNumServers];
} 

// 2 marks
// Return the index of the server with the given name; otherwise return -1
private int FindServer(string name) 
{
    int i;
    for (i = 0; i < NumServers; i++)
    {  
        if (V[i].Equals(name))
            return i;
    }
    return -1;
}

// 3 marks
// Double the capacity of the server graph with the respect to web servers
private void DoubleCapacity( ) {
	MaxNumServers = MaxNumServers * 2;
}

// Create Add Vertex method
// To be called inside Add Server method
public bool AddVertex(T name)
{
	int i;
	if (NumServers < MaxNumServers && FindServer(name) == -1)
	{
		V[NumServers] = name;
		for (i = 0; i <= NumServers; i++)
		{
			E[i, NumServers] = -1;
			E[NumServers, i] = -1;
		}
		NumServers++;
		return true;
	}

	return false;
}

// 3 marks
// Add a server with the given name and connect it to the other server
// Return true if successful; otherwise return false
public bool AddServer(string name, string other) {
	bool vertexAdded = AddVertex(name);
	if (VertexAdded == true)
	{
		bool connectionAdded = AddConnection(name, other);
		if (connectionAdded == true)
			return true;
		else
			return false;
	}
}

// 3 marks
// Add a webpage to the server with the given name
// Return true if successful; otherwise return false
public bool AddWebPage(WebPage w, string name) 
 {
        //have a list for webpages to be stored
        //List<WebPage> P = new List<WebPage>(w);  //idk if w should be in brackets https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.add?view=net-8.0
        //bool WebPageAdded = P.Any(); //Any checks if list contains an element https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.any?view=net-8.0&redirectedfrom=MSDN#overloads
 
        //P.Add(new WebPage(name));

        //if (WebPageAdded == true)
            //return true;
        //else
            //return false;
    }

// 4 marks
// Remove the server with the given name by assigning its connections
// and webpages to the other server
// Return true if successful; otherwise return false
public bool RemoveServer(string name, string other)
{
	int i, j;
	if ((i = FindServer(name)) > -1)
	{
		NumServers--;
		V[i] = V[NumServers];
		for (j = NumServers; j >= 0; j--)
		{
			E[j, i] = E[j, NumServers];
			E[i, j] = E[NumServers, j];
			return true;	
		}
	return false;
	}
}

// 3 marks (Bonus)
// Remove the webpage from the server with the given name
// Return true if successful; otherwise return false
public bool RemoveWebPage(string webpage, string name) ...

// 3 marks
// Add a connection from one server to another
// Return true if successful; otherwise return false
// Note that each server is connected to at least one other server
public bool AddConnection(string from, string to)
{
	int i, j;
	if ((i = FindServer(from)) > -1 && (j = FindServer(to)) > -1)
		if (E[i, j] == -1)
			E[i, j] = 1;
			return true;

	return false;
}

// 10 marks
// Return all servers that would disconnect the server graph into
// two or more disjoint graphs if ever one of them would go down
// Hint: Use a variation of the depth-first search
public string[] CriticalServers( ) ...

// 6 marks
// Return the shortest path from one server to another
// Hint: Use a variation of the breadth-first search
// Source: https://www.geeksforgeeks.org/shortest-path-unweighted-graph/
public int ShortestPath(string from, string to)
{
	// predecessor [i] array stores predecessor of i
	// distance array stores distance of i from s
	int[] pred = new int[NumServers];
	int[] dist = new int[NumServers];

	// TO COMPLETE
	// Call method BFS
	// Check if vertices are connected
	// Output error message if not connected
	if (BFS(E, from, to, NumServers, pred, dist) == false)
	{
		Console.WriteLine("Given source and destination are not connected");
		// IS RETURNING -1 OKAY?
		return -1;
	}

	// Create a list to store the path
	List<int> path = new List<int>();
	int crawl = dest;
	path.Add(crawl);

	while(pred[crawl] != -1)
	{
		path.Add(pred[crawl]);
		crawl = pred[crawl];
	}

	// Print distance
	// REVIEW THIS!
	// MIGHT HAVE TO JUST RETURN A NUMBER, INTEGER
	// Console.WriteLine("Shortest path from server " + from + " to server " + to + " is: " + dist[to]);

	// Print path
	// Console.WriteLine("Path is: ");

	//for(int i = path.Count - 1; i >= 0; i--)
	//{
	//	Console.Write(path[i] + " ");
	//}

	// Return statement
	return dist[to];

	// Modified version of BFS that stores predecessor of each vertex in array pred and its distance from source in array dist
	// Might have to pass variables as parameters
	private static bool BFS(bool[,] E, int from, int to, int NumServers, int[] pred, int[]dist)
	{
		// a queue to maintain queue of vertices who adjancency matrix is to be scanned as per normal BFS algorithm using List of int type
		List<int> queue = new List<int>();

		// bool array visited
		// stores information of whether or not vertex i is reached at least once in the BFS
		bool []visited = new bool[NumServers];

		// Set all vertices as unvisited, so visited[i] for all i is false
		// no path constructed yet, so dist[i] set to infinity 
		for (int i = 0; i < v; i++)
		{
			visited[i] = false;
			dist[i] = int.MaxValue;
			pred[i] = -1;
		}

		// now source is first to be visited and distance from source to itself should be 0
		visited[from] = true;
		dist[from] = 0;
		queue.Add(from);

		// BFS Algorithm
		while (queue.Count != 0)
		{
			int u = queue[0];
			queue.RemoveAt(0);

			for (int i = 0; i < E[u].Count; i++)
			{
				if (visited[E[u, i]] == false)
				{
					visited[E[u, i]] = true;
					dist[E[u, i]] = dist[u] + 1;
					pred[E[u, i]] = u;
					queue.Add(E[u, i]);

					// stopping condition (when we find our destination)
					if (E[u, i] == dest)
						return true;
				}
			}
		}
		return false;
	}
}

// Method to print all servers
// To be called in Print graph method
public void PrintServers()
{
	int i;
	for (i = 0; i < NumServers; i++)
		Console.WriteLine(V[i]);
}

// Method to print all connections
// To be called in Print graph method
public void PrintConnections()
{
	int i, j;
	for (i = 0; i < NumServers; i++)
		for (j = 0; j < NumServers; j++)
			if (E[i, j] > -1)
				Console.WriteLine("(" + V[i] + "," + V[j] + "," + E[i, j] + ")");
}

// 4 marks
// Print the name and connections of each server as well as
// the names of the webpages it hosts

////////////////////////////////
// MISSING PRINT WEBPAGES!!
////////////////////////////////

public void PrintGraph( ) 
{
	PrintServers();
	PrintConnections();
}
}
