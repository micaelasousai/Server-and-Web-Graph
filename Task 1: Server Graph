// Name: Micaela Sousa (0722724), Rachel Lee (0696297), Boaz Chan (0686531)
// Assignment 1

// Program description:
// TO COMPLETE!!!

// Data dictionary: 
// TO COMPLETE!!!

// Task 1: Server Graph
namespace Graphs
{ 
	public class ServerGraph
	{
		// 3 marks
		private class WebServer
		{
			public string Name;
			public List<WebPage> P;
		}

		private WebServer[] V { set; get; } 
		private bool[,] E { set; get; }
		private int NumServers { set; get; }
		private int MaxNumServers { set; get; }


		// 2 marks
		// Create an empty server graph
		// Parameter: name of the initial server in the graph
		public ServerGraph(string name)
		{
			NumServers = 0;
			MaxNumServers = 10;
			V = new WebServer[10];
			E = new bool[10, 10];

			// Create an initial server for the graph
			WebServer newVertex = new WebServer();
			newVertex.Name = name;
			V[NumServers] = newVertex;			
			E[0, 0] = false;
			NumServers++;
		}

		// 2 marks
		// Return the index of the server with the given name; otherwise return -1
		private int FindServer(string name)
		{
			int i;
			for (i = 0; i < NumServers; i++)
			{
				if (V[i].Equals(name))
					return i;
			}
			return -1;
		}

		// Returns the name of the server that hosts a specific webpage
		public string FindHost(string webpage)
        	{
			for (int x = 0; x < NumServers; x++)
            		{
				if (V[x].P.Any(page => page.Name == webpage))
				{
					return V[x].Name;
                		}
            		}
			return "";
		}

		// 3 marks
		// Double the capacity of the server graph with the respect to web servers
		private void DoubleCapacity()
		{

			// reference is from: https://www.dotnetperls.com/array-resize
			//reference is from: https://stackoverflow.com/questions/15725840/copy-one-2d-array-to-another-2d-array
			WebServer[] newWebServers = new WebServer[2 * MaxNumServers];   //creates numWebServer 2x bigger than server graph
			for (int i = 0; i < NumServers; i++)
			{
				newWebServers[i] = V[i];    // copies the original array
				double[,] edgeM = (double[,])E.Clone(); //copies the edge matrix
			}
			V = newWebServers;
			MaxNumServers = MaxNumServers * 2;
		}

		// Create Add Vertex method
		// To be called inside Add Server method
		public bool AddVertex(string name)
		{
			int i;

			// If the number of servers is greater or equal than the maximum number of servers, call the method double capacity
			if (NumServers >= MaxNumServers)
            {
				DoubleCapacity();
            }

			// Add new vertex if there is capacity and the server does not exist in the graph
			if (NumServers < MaxNumServers && FindServer(name) == -1)
			{
				// Instantiate new object type webserver
				WebServer newVertex = new WebServer();
				newVertex.Name = name;
				V[NumServers] = newVertex;
				for (i = 0; i <= NumServers; i++)
				{
					E[i, NumServers] = false;
					E[NumServers, i] = false;
				}
				// Increase the total number of servers by 1
				NumServers++;
				// When addition of new server is successful, return true
				return true;
			}
			// When addition of new server is unsuccessful, return false
			return false;
		}

		// 3 marks
		// Add a server with the given name and connect it to the other server
		// Return true if successful; otherwise return false
		public bool AddServer(string name, string other)
		{
			bool vertexAdded = AddVertex(name);
			if (vertexAdded == true)
			{
				bool connectionAdded = AddConnection(name, other);
				if (connectionAdded == true)
					return true;
				else
					return false;
			}
			return false;
		}

		// 3 marks
		// Add a webpage to the server with the given name
		// Return true if successful; otherwise return false
		public bool AddWebPage(WebPage w, string name) //note: added the string host to the AddWebPage
		{
			// Find the index of the server passed
			int i = FindServer(name);

			// If there is no valid index associated with the given name, print an error message and return false
			if (i < 0)
            		{
				Console.WriteLine("There is no server associated with the name provided. Enter a valid server name to add the webpage.");
				return false;
            		}
			else
            		{
				// If there webpage has not been added already to the list of webpages, add it
				if (V[i].P.Contains(w) == false)
				{ 
					V[i].P.Add(w); //adding WebPage w to the list
					return true;   // return true if addition is successful
				}
				else
				{
					return false;  // return false if addition is unsuccessful
				}
            		}
			
		}

		// 4 marks
		// Remove the server with the given name by assigning its connections
		// and webpages to the other server
		// Return true if successful; otherwise return false
		public bool RemoveServer(string name, string other)
		{
			int i, j;
			if (NumServers == 1)
			{
				Console.WriteLine("You cannot the last server in the server graph. There should be at least one server in the graph.");
				return false;
			}
			else
			{
				if ((i = FindServer(name)) > -1)
				{
					NumServers--;
					V[i] = V[NumServers];
					for (j = NumServers; j >= 0; j--)
					{
						E[j, i] = E[j, NumServers];
						E[i, j] = E[NumServers, j];
						return true;
					}
					return false;
				}
			}
			return false;
		}

		// 3 marks (Bonus)
		// Remove the webpage from the server with the given name
		// Return true if successful; otherwise return false
		public bool RemoveWebPage(string webpage, string name)
		{
			// Find the index of the server passed
			int i = FindServer(name);

			// If there is no valid index associated with the given name, print an error message and return false
			if (i < 0)
			{
				Console.WriteLine("There is no server associated with the name provided. Enter a valid server name to add the webpage.");
				return false;
			}
			else
			{
				// Find the index of the web page associated with the webpage name passed
				int indexWebpage = V[i].P.FindIndex(page => page.Name == webpage);
				if (indexWebpage != -1)
                		{
					// Remove the webpage from the list of webpages of the specified server
					V[i].P.RemoveAt(indexWebpage);
					return true;
                		}
				else
				{
					return false;

				}
			}
		}

		// 3 marks
		// Add a connection from one server to another
		// Return true if successful; otherwise return false
		// Note that each server is connected to at least one other server
		public bool AddConnection(string from, string to)
		{
			int i, j;
			if ((i = FindServer(from)) > -1 && (j = FindServer(to)) > -1)
				if (E[i, j] == false)
				{
					E[i, j] = true;
					return true;
				}
			return false;
		}

		// 10 marks
		// Return all servers that would disconnect the server graph into
		// two or more disjoint graphs if ever one of them would go down
		// Hint: Use a variation of the depth-first search
		public void DepthFirstSearch(int i, bool[] visited)
		{
			int j;
			visited[i] = true;
			Console.WriteLine(i);

			for (j = 0; j < NumServers; j++)
				if (!visited[j] && E[i, j] == true)
					DepthFirstSearch(j, visited);
		}



		public string[] CriticalServers(int i, bool[] visited)
		{
			//iterates over all vertices in graph; for each vertex i, remove the vertex
			//and check whether graph remains connected
			for (int k = 1; k <= NumServers; k++)
			{
				//keeps track of graph components
				int components = 0;

				//keeps track of visited vertices
				int[] vis = new int[NumServers + 1];

				//array to store what this method will return
				string[] strvis = new string[NumServers + 1];

				//iterates over graph after removing vertex k and associated edges
				for (int j = 1; j <= NumServers; j++)
				{
					//if the 'j'th vertex is not visited it will form new component
					if (j != k)
					{
						if (vis[j] == 0)
						{
							components++;
							DepthFirstSearch(j, visited);
						}
					}
				}

				if (components > 1)
				{
					Console.WriteLine(k);
				}
				//converts integer array of critical indexes into strings to return to system
				strvis[k] = vis[k].ToString();
				
			}
			return strvis;

		}
	


		// 6 marks
		// Return the shortest path from one server to another
		// Hint: Use a variation of the breadth-first search
		public int ShortestPath(string from, string to)
		{
			// declare variables
			int fromIndex;
			int toIndex;
			int shortestPath;       // Variable to be returned

			// get index of the "from" and "to" servers
			fromIndex = FindServer(from);
			toIndex = FindServer(to);


			bool[] visited = new bool[NumServers];
			// distance array stores the distance
			int[] dist = new int[NumServers];

			for (int i = 0; i < NumServers; i++)
				visited[i] = false;               // Set all vertices as unvisited


			// If statement to check if the names passed are valid server names
			// Check if none of the server names is valid
			if (fromIndex < 0 && toIndex < 0)
			{
				Console.WriteLine("Please provide valid names for both of the servers to get the shortest path between them.");
				return -1;
			}
			// Check if the first server name is invalid
			else if (fromIndex < 0)
			{
				Console.WriteLine("Please provide a valid name for the first server you are passing to get the shortest path between the servers.");
				return -1;
			}
			// Check if the second server name is invalid
			else if (toIndex < 0)
			{
				Console.WriteLine("Please provide a valid name for the second server you are passing to get the shortest path between the servers.");
				return -1;
			}
			// If both server names are valid, call the breadth first search method
			else
			{
				// Call BFS from server "from" to server "to"
				shortestPath = BreadthFirstSearch(fromIndex, toIndex, visited, dist);
				Console.WriteLine();
			}

			return shortestPath;

		}


		// Modified version of BFS stores distance from one vertex to the other in array dist
		// To be called inside method Shortest Path
		private int BreadthFirstSearch(int i, int k, bool[] visited, int[] dist)
		{
			// declare the variables
			int j;

			Queue<int> Q = new Queue<int>();
			Q.Enqueue(i);       //  Mark vertex as visited when placed in the queue
			visited[i] = true;

			while (Q.Count != 0)
			{
				i = Q.Dequeue();

				for (j = i; j < NumServers; j++)    // Enqueue unvisited adjacent vertices
					if (!visited[j] && E[i, j] == true)
					{
						// Distance of i is equal to the distance of the parent + 1
						dist[j] = dist[j - 1] + 1;

						// if j != k then execute the following two lines
						if (j != k)
						{
							Q.Enqueue(j);
							visited[j] = true;     // Mark vertex as visited
						}
						else
						{
							return dist[j];
						}
					}
			}

			// No shortest path found
			// Return -1
			return -1;
		}

		// Method to print all servers
		// To be called in Print graph method
		public void PrintServers()
		{
			int i;
			for (i = 0; i < NumServers; i++)
				Console.WriteLine("Server: " + V[i].Name);
		}

		// Method to print all connections
		// To be called in Print graph method
		public void PrintConnections()
		{
			int i, j;
			for (i = 0; i < NumServers; i++)
				for (j = 0; j < NumServers; j++)
					if (E[i, j] == true)
						Console.WriteLine("Connection: (" + V[i] + "," + V[j] + "," + E[i, j] + ")");
		}

		// PrintWebPagesHosted
		// Prints out all the web pages each server hosts
		// To be called inside the PrintGraph method
		public void PrintWebPagesHosted()
		{
			// Go over each of the servers stored in V
			for (int i = 0; i < NumServers; i++)
				// Print the webpages for each server V[i] stored in list P
				for (int j = 0; j < V[i].P.Count; j++)
					Console.WriteLine(V[i].P[j].Name + " hosted by " + V[i].Name);
			Console.ReadLine();
		}

		// 4 marks
		// Print the name and connections of each server as well as
		// the names of the webpages it hosts

		public void PrintGraph()
		{
			PrintServers();
			PrintConnections();
			PrintWebPagesHosted();
		}
	}
}
