// Create a class for Edge
public class Edge<T>
    {
        public WebPage<T> AdjVertex { get; set; }
        public int Cost { get; set; }

        public Edge(Webpage<T> webpage, int cost = -1)
        {
            AdjVertex = webpage;
            Cost = 1;
        }
    }

// 5 marks
public class WebPage
{
public string Name {get; set;}
public string Server {get; set;}
public List<WebPage> E {get; set;}
...

// Constructor for Web page
public WebPage(string name, string host) {
	Name = name;
	Server = host;
	// Should we keep this?
	Visited = false;
	E = new List<WebPage>();
}

// Find link method
// Returns the index of the given adjacent vertex in E; otherwise returns -1
// Time complexity: O(n) where n is the number of vertices
public int FindLink(string name) {
	int i;
	for (i = 0; i < E.Count; i++)
	{
		if (E[i].AdjVertex.Name.Equals(name))
			return i;
	}
	return -1;
}

...
}
public class WebGraph
{
private List<WebPage> P;
...

// 2 marks
// Create an empty WebGraph
public WebGraph( ) {
	V = new List<WebPage>();
}

// 2 marks
// Return the index of the webpage with the given name; otherwise return -1
private int FindPage(string name) {
	int i;
	for (i = 0; i < V.Count; i++)
	{
		if (V[i].Name.Equals(name))
			return i;
	}
	return -1;
}

// 4 marks
// Add a webpage with the given name and store it on the host server
// Return true if successful; otherwise return false
public bool AddPage(string name, string host, ServerGraph S)
    {
        if (FindPage(name) == -1)
        {
            WebPage<P> page = new WebPage<P>(name);
            V.Add(page);
            return true;
        }
            return false;  
    }

// 8 marks
// Remove the webpage with the given name, including the hyperlinks
// from and to the webpage
// Return true if successful; otherwise return false
public bool RemovePage (string name, ServerGraph S) {
	int i, j, k;
	if ((i = FindPage(name)) > -1)
	{
		for (j = 0; j < V.Count; j++)
		{
			for (k = 0; k < V[j].E.Count; k++)
				if (V[j].E[k].AdjVertex.Name.Equals(name)) // Incident edge
				{
					V[j].E.RemoveAt(k);
					break; // Since there are no duplicate edges
				}
		}
		V.RemoveAt(i);
	}

	// Remove webpage from the list of webpages of host server
	// TO COMPLETE!!!

	// Return true or false if operation is successful
	// TO COMPLETE!!
}

// 3 marks
// Add a hyperlink from one webpage to another
// Return true if successful; otherwise return false
public bool AddLink (string from, string to) 
{
	int i,j;
	int k = 0;
	Edge<T> e;

	// Do the vertices exist?
	if ((i = FindPage(from)) > -1 && (j = FindPage(to) > -1)
	{
		// Does the edge not already exist?
		if (V[i].FindLink(to) == -1)
		{
			e = new Edge<T>(V[j], k);
			V[i].E.Add(e);
			return true;
		}
	}
	return false;
}

// 3 marks
// Remove a hyperlink from one webpage to another
// Return true if successful; otherwise return false
public bool RemoveLink (string from, string to) {
	int i, j;
	if ((i = FindPage(from)) > -1 && (j = V[i].FindPage(to)) > -1)
	{
		V[i].E.RemoveAt(j);
		return true;
	}
	return false;
}

// 6 marks
// Return the average length of the shortest paths from the webpage with
// given name to each of its hyperlinks
// Hint: Use the method ShortestPath in the class ServerGraph
public float AvgShortestPaths(string name, ServerGraph S) ...

// PrintPages
// Prints out all vertices of a graph
// Time complexity: O(n)
// To be called inside the PrintGraph method
public void PrintPages()
{
	for (int i = 0; i < V.Count; i++)
		Console.WriteLine(V[i].Name);
	Console.ReadLine();
}

// PrintLinks
// Prints out all edges of the graph
// Time complexity: O(m)
// To be called inside the PrintGraph method
public void PrintLinks()
{
	int i, j;
	for (i = 0; i < V.Count; i++)
		for (j = 0; j < V[i].E.Count; j++)
			Console.WriteLine("(" + V[i].Name + "," + V[i].E[j].AdjVertex.Name + ")");
    Console.ReadLine();
}

// 3 marks
// Print the name and hyperlinks of each webpage
public void PrintGraph( ) {
	PrintPages();
	PrintLinks();
}
}
