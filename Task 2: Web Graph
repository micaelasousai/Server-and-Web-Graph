// Name: Micaela Sousa (0722724), Rachel Lee (0696297), Boaz Chan (0686531)
// Assignment 1

// Program description:
// TO COMPLETE!!!

// Data dictionary: 
// TO COMPLETE!!!

// Task 2: Web Graph

namespace Graphs {


	// Create a class for Edge
	public class Edge
	{
		public WebPage AdjVertex { get; set; }
		public int Cost { get; set; }

		public Edge(WebPage webpage)
		{
			AdjVertex = webpage;
			Cost = -1;
		}
	}

	// 5 marks
	public class WebPage
	{
		public string Name { get; set; }    // Vertex name (webpage name)
		public string Server { get; set; }
		public List<Edge> E { get; set; }   // List of adjancency vertices (webpages)


		// Constructor for Web page
		public WebPage(string name, string host)
		{
			Name = name;
			Server = host;
			// Keep track of list of edges
			E = new List<Edge>();
		}

		// Find link method
		// Returns the index of the given adjacent vertex in E; otherwise returns -1
		// Time complexity: O(n) where n is the number of vertices
		public int FindLink(string name)
		{
			int i;
			for (i = 0; i < E.Count; i++)
			{
				if (E[i].AdjVertex.Name.Equals(name))
					return i;
			}
			return -1;
		}
	}
	public class WebGraph
	{
		private List<WebPage> V;

		// 2 marks
		// Create an empty WebGraph
		public WebGraph()
		{
			V = new List<WebPage>();
		}

		// 2 marks
		// Return the index of the webpage with the given name; otherwise return -1
		private int FindPage(string name)
		{
			int i;
			for (i = 0; i < V.Count; i++)
			{
				if (V[i].Name.Equals(name))
					return i;
			}
			return -1;
		}

		// 4 marks
		// Add a webpage with the given name and store it on the host server
		// Return true if successful; otherwise return false
		public bool AddPage(string name, string host, ServerGraph S)
		{
			if (FindPage(name) == -1)
			{
				WebPage page = new WebPage(name, host);
				V.Add(page);

				// Connect it to server graph
				// Call Method Add WebPage
				S.AddWebPage(page, name);

				return true;
			}
			return false;
		}

		// 8 marks
		// Remove the webpage with the given name, including the hyperlinks
		// from and to the webpage
		// Return true if successful; otherwise return false
		public bool RemovePage(string name, ServerGraph S)
		{
			int i, j, k;
			if ((i = FindPage(name)) > -1)
			{
				for (j = 0; j < V.Count; j++)
				{
					for (k = 0; k < V[j].E.Count; k++)
						if (V[j].E[k].AdjVertex.Name.Equals(name)) // Incident edge
						{
							V[j].E.RemoveAt(k);
							break; // Since there are no duplicate edges
						}
				}
				V.RemoveAt(i);
			}

			// Remove webpage from the list of webpages of host server
			// TO COMPLETE!!!
			// CALL METHOD REMOVE WEBPAGE

			// Return true or false if operation is successful
			// TO COMPLETE!!
		}

		// 3 marks
		// Add a hyperlink from one webpage to another
		// Return true if successful; otherwise return false
		public bool AddLink(string from, string to)
		{
			int i, j;
			// int k = 0;
			Edge e;

			// Do the vertices exist?
			if ((i = FindPage(from)) > -1 && (j = FindPage(to)) > -1)
			{
				// Does the edge not already exist?
				if (V[i].FindLink(to) == -1)
				{
					e = new Edge (V[j]);
					V[i].E.Add(e);
					// This indicates that an edge exists 
					e.Cost = 1;
					return true;
				}
			}
			return false;
		}

		// 3 marks
		// Remove a hyperlink from one webpage to another
		// Return true if successful; otherwise return false
		public bool RemoveLink(string from, string to)
		{
			int i, j;
			if ((i = FindPage(from)) > -1 && (j = V[i].FindLink(to)) > -1)
			{
				V[i].E.RemoveAt(j);
				return true;
			}
			return false;
		}

		// 6 marks
		// Return the average length of the shortest paths from the webpage with
		// given name to each of its hyperlinks
		// Hint: Use the method ShortestPath in the class ServerGraph

		///////////////////////////
		//note: this isn't how BP recommended us to do it --> will change the AvgShortestPaths afterwards
		//////////////////////////
		//public float AvgShortestPaths(string name, ServerGraph S, int v, int[] distance, int[] pred, int destination)
		//{
		//	//reference for bfs is from: https://www.geeksforgeeks.org/shortest-path-unweighted-graph/
		//	bool[] visited = new bool[v];   //checks in vertex is reached at least once

		//	for (int i = 0; i < v; i++)
		//	{
		//		visited[i] = false;
		//		distance[i] = int.MaxValue;
		//		pred[i] = -1;
		//	}

		//	visited[S] = true;
		//	distance[S] = 0;
		//	P.Add(S);

		//	// the breadth first search
		//	while (P.Count != 0)
		//	{
		//		int a = P[0];
		//		P.RemoveAt(0);

		//		for (int i = 0; i < S[a].Count; i++)
		//		{
		//			if (visited[S[a][i]] == false)
		//			{
		//				visited[S[a][i]] = true;
		//				distance[(int)S[a][i]] = distance[a] + 1;
		//				pred[S[a][i]] = a;
		//				P.Add((int)S[a][i]);

		//				if (S[a][i] == destination)
		//					return 1;
		//			}
		//		}
		//	}
		//	return -1;


			// PrintPages
			// Prints out all vertices of a graph
			// Time complexity: O(n)
			// To be called inside the PrintGraph method
			public void PrintPages()
			{
				for (int i = 0; i < V.Count; i++)
					Console.WriteLine(V[i].Name);
				Console.ReadLine();
			}

			// PrintLinks
			// Prints out all edges of the graph
			// Time complexity: O(m)
			// To be called inside the PrintGraph method
			public void PrintLinks()
			{
				int i, j;
				for (i = 0; i < V.Count; i++)
					for (j = 0; j < V[i].E.Count; j++)
						Console.WriteLine("(" + V[i].Name + "," + V[i].E[j].AdjVertex.Name + ")");
				Console.ReadLine();
			}

			// 3 marks
			// Print the name and hyperlinks of each webpage
			public void PrintGraph()
			{
				PrintPages();
				PrintLinks();
			}
		}
	}
}
